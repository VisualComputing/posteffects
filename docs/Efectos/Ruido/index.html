<!doctype html><html lang=es-co dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Ruido # Los algoritmos de ruido han sido una elegante forma de abordar problemas en distintas áreas, esto se debe a su capacidad para relacionarse con comportamientos caóticos o simplemente aleatorios. Han sido utilizados en la generación de terreno de forma procedural, simulación de físicas de movimiento de fluidos, texturización procedural para obtener materiales más realistas, etc.
En esta sección, se hará uso de un algoritmo generador de ruido para causar distorsiones y movimiento en una imagen determinada."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Ruido # Los algoritmos de ruido han sido una elegante forma de abordar problemas en distintas áreas, esto se debe a su capacidad para relacionarse con comportamientos caóticos o simplemente aleatorios. Han sido utilizados en la generación de terreno de forma procedural, simulación de físicas de movimiento de fluidos, texturización procedural para obtener materiales más realistas, etc.
En esta sección, se hará uso de un algoritmo generador de ruido para causar distorsiones y movimiento en una imagen determinada."><meta property="og:type" content="article"><meta property="og:url" content="https://visualcomputing.github.io/posteffects/docs/Efectos/Ruido/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-09-28T11:14:40-05:00"><title>Ruido | Posteffects</title><link rel=manifest href=/posteffects/manifest.json><link rel=icon href=/posteffects/favicon.png type=image/x-icon><link rel=stylesheet href=/posteffects/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/posteffects/flexsearch.min.js></script>
<script defer src=/posteffects/en.search.min.33dc2156399ffb66286db5e765f4d21ccac89de4638907a9d753132b575102c1.js integrity="sha256-M9whVjmf+2YobbXnZfTSHMrIneRjiQep11MTK1dRAsE=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/posteffects/><span>Posteffects</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><input type=checkbox id=section-0f516780f0e03c1811ded5819441605a class=toggle checked>
<label for=section-0f516780f0e03c1811ded5819441605a class="flex justify-between"><a role=button>Efectos</a></label><ul><li><a href=/posteffects/docs/Efectos/Mapa-de-Profundidad/>Mapa De Profundidad</a></li><li><a href=/posteffects/docs/Efectos/Profundidad-de-Campo/>Profundidad De Campo</a></li><li><a href=/posteffects/docs/Efectos/Pixelador/>Pixelador</a></li><li><a href=/posteffects/docs/Efectos/Detecci%C3%B3n-de-Bordes/>Detección De Bordes</a></li><li><a href=/posteffects/docs/Efectos/Desenfoque-Horizontal/>Desenfoque Horizontal</a></li><li><a href=/posteffects/docs/Efectos/Caleidoscopio/>Caleidoscopio</a></li><li><a href=/posteffects/docs/Efectos/Ruido/ class=active>Ruido</a></li><li><a href=/posteffects/docs/Efectos/Rayos/>Rayos</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-039690677835ee748aa00d86a9f370b9 class=toggle>
<label for=section-039690677835ee748aa00d86a9f370b9 class="flex justify-between"><a role=button>Apéndices</a></label><ul><li><a href=/posteffects/docs/Ap%C3%A9ndices/Apuntes-de-p5.treegl/>Apuntes De P5.treegl</a></li></ul></li><li class=book-section-flat><span>Monitoría Poo</span><ul><li><a href=/posteffects/docs/Monitor%C3%ADa-POO/Introducci%C3%B3n-a-JavaScript/>Introducción a Java Script</a></li><li><a href=/posteffects/docs/Monitor%C3%ADa-POO/Introducci%C3%B3n-a-p5/>Introducción a P5</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/posteffects/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Ruido</strong>
<label for=toc-control><img src=/posteffects/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#ruido>Ruido</a><ul><li><a href=#código-del-fragment-shader-del-efecto>Código del Fragment Shader del efecto:</a><ul><li><a href=#ruido-simplex>Ruido Simplex.</a></li><li><a href=#función-principal>Función Principal</a></li></ul></li><li><a href=#referencias>Referencias:</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=ruido>Ruido
<a class=anchor href=#ruido>#</a></h1><p>Los algoritmos de ruido han sido una elegante forma de abordar problemas
en distintas áreas, esto se debe a su capacidad para relacionarse con comportamientos
caóticos o simplemente aleatorios. Han sido utilizados en la generación de terreno de forma
procedural, simulación de físicas de movimiento de fluidos, texturización procedural para obtener
materiales más realistas, etc.</p><p>En esta sección, se hará uso de un algoritmo generador de ruido para causar distorsiones y movimiento
en una imagen determinada.</p><iframe id=sketch style=width:625px;height:325px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/addons/p5.sound.min.js></script>
             <script src=https://cdn.jsdelivr.net/gh/freshfork/p5.EasyCam/p5.easycam.js></script> 
             <script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js></script> 
            
            
            
            <script src=/posteffects/sketches/ruido/sketch.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h2 id=código-del-fragment-shader-del-efecto>Código del Fragment Shader del efecto:
<a class=anchor href=#c%c3%b3digo-del-fragment-shader-del-efecto>#</a></h2><details open><summary>noise.frag</summary><div class=markdown-inner><pre tabindex=0><code>precision mediump float;

uniform sampler2D tex;
uniform float frequency;
uniform float amplitude;
uniform float time;
uniform float speed;

varying vec2 texcoords2;

vec3 mod289(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
    return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r){
	return 1.79284291400159 - 0.85373472095314 * r;
}

float snoise(vec3 v){
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;
                
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy; 
    vec3 x3 = x0 - D.yyy;      
                
    // Permutations
    i = mod289(i);
    vec4 p = permute( permute( permute(
        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                
    float n_ = 0.142857142857; // 1.0/7.0
    vec3  ns = n_ * D.wyz - D.xzx;
                
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );
                
    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
                
    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
                
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                
    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);
                
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;

    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
        dot(p2,x2), dot(p3,x3) ) );
}

void main() {
    vec2 texCoords = texcoords2.st + vec2(
        amplitude * (snoise(vec3(frequency * texcoords2.s, frequency * texcoords2.t, speed * time))),
        amplitude * (snoise(vec3(frequency * texcoords2.s + 17.0, frequency * texcoords2.t, speed * time)))
    );
    gl_FragColor = texture2D(tex, texCoords);
}
</code></pre></div></details><p>Lo primero en hacerse es definir ciertas funciones importantes
para el desarrollo de este efecto y la mejora de su desempeño. En primer
lugar, considerando que <code>glsl</code> no cuenta con una operación de módulo, que se
define como:
<link rel=stylesheet href=/posteffects/katex/katex.min.css><script defer src=/posteffects/katex/katex.min.js></script>
<script defer src=/posteffects/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>
\[\mod(x, n) = x - n \cdot \lfloor \frac{x}{n} \rfloor\]</span></p><p>Se implementa <span>\( \mod(\vec v, 289) \)</span>
para vectores de
tres y cuatro dimensiones.</p><pre tabindex=0><code>vec3 mod289(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}
</code></pre><p>También se implementa una función para operaciones de permutación, que en
este caso se refiere a una operación de hashing que se usará posteriormente. Es<br>importante añadir que es gracias a esta que el ruido adquiere su característico comportamiento
seudoaleatorio.</p><pre tabindex=0><code>vec4 permute(vec4 x) {
    return mod289(((x*34.0)+1.0)*x);
}
</code></pre><p>En ocasiones en las que se puede prescindir de la exactitud, es
factible usar aproximaciones a funciones conocidas en pos de disminuir
el tiempo de ejecución. Una buena forma de obtener estas aproximaciones es
el uso de series de Taylor; la que será implementada es:</p><span>\[\frac{1}{\sqrt{x}} \aprox 1.79284291400159 - 0.85373472095314 \cdot x\]</span><pre tabindex=0><code>vec4 taylorInvSqrt(vec4 r){
    return 1.79284291400159 - 0.85373472095314 * r;
}
</code></pre><h3 id=ruido-simplex>Ruido Simplex.
<a class=anchor href=#ruido-simplex>#</a></h3><p>La función más importante de este efecto se conoce como <strong>Ruido Simplex</strong>, una
mejora considerable sobre el <strong>Ruido de Perlin</strong> en términos de eficiencia computacional. Una de
sus ventajas es la versatilidad que demuestra al poder ser implementada para cualquier dimensión, en este
caso se usarán tres.</p><pre tabindex=0><code>float snoise(vec3 v){
    ...
}
</code></pre><p>Conforme se hagan acercamientos a diferentes fragmentos
de esta función, se darán algunas generalidades del funcionamiento de
este algoritmo.
En primer lugar, se definen algunas constantes vitales para el resto de los cálculos.</p><pre tabindex=0><code>    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
</code></pre><p>La segunda componente de <code>C</code>, que es el factor que determina la distancia
entre el baricentro de un triángulo y el lado que su mediana interseca, funge como
factor de sesgo; la primera componente ayudará a deshacer dicha transformación.</p><p>El algoritmo supone una malla de tetraedros irregulares abarcando el espacio y, por tanto, conteniendo
los puntos de interés. Para mayor entendimiento, de momento es menester hacerse de una imagen geométrica de cada paso.</p><pre tabindex=0><code>    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;
</code></pre><p>Como el punto actual (<code>v</code>) se encuentra en uno de los 24 tetraedros
que llenan el espacio, es importante saber cual lo contiene, y una buena forma de
empezar es hallar una esquina inicial.</p><p>Para alinear la malla con los ejes espaciales, se hace una transformación de sesgo sobre
el mundo y extrayendo las partes enteras de cada componente del vector <code>v</code>transformado es posible
determinar en qué tetraedro se encuentra. Basta con deshacer el sesgado y restar ese antiguo indicador
de ubicación a <code>v</code> para hallar elorigen deseado (<code>x0</code>).</p><p>Ahora se debe encontrar el resto de los vértices</p><pre tabindex=0><code>    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );            
    
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
</code></pre><p>Las funciones de paso son una buena forma de comparar los vectores y determinar
cuales son los puntos más cercanos al origen del tetraedro para hallar los vértices
de forma ordenada.</p><p>Se realiza una serie de permutaciones concatenadas sobre sumas de las componentes del vector <code>i</code></p><pre tabindex=0><code>    i = mod289(i);
    vec4 p = permute( permute( permute(
        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
</code></pre><p>Este vector <code>p</code> contiene ahora valores seudo aleatorios con los que
se podrá acceder posteriormente a los gradientes y que además garantizan que
los patrones formados por el ruido no sean repetitivos.</p><p>Gracias a la constante <code>D</code> se define un vector de normalización que servirá para
calcular las coordenadas de los vértices y sus gradientes después de haber pasado
por la permutación.</p><pre tabindex=0><code>    float n_ = 0.142857142857; // 1.0/7.0
    vec3  ns = n_ * D.wyz - D.xzx;
                
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );
                
    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
                
    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
                
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                
    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);
</code></pre><p>Luego de haber obtenido los gradientes, estos deben
ser normalizados y mezclados.</p><pre tabindex=0><code>    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
</code></pre><p>Finalmente, se calcula el efecto de dichos gradientes sobre
el punto de entrada y se retorna como resultado de la función.</p><pre tabindex=0><code>    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
        dot(p2,x2), dot(p3,x3) ) );
</code></pre><h3 id=función-principal>Función Principal
<a class=anchor href=#funci%c3%b3n-principal>#</a></h3><p>Una vez desarrollado el algoritmo de ruido simplex, queda hacer uso de él
y aplicarl, en este caso sobre los colores de la escena.
La textura se muestrea de modo que la amplitud, frecuencia y velocidad alteren la forma de las oscilaciones del ruido, que
también dependerá principalmente del tiempo (en milisegundos) transcurrido desde la ejecución del programa.</p><pre tabindex=0><code>void main() {
    vec2 texCoords = texcoords2.st + vec2(
        amplitude * (snoise(vec3(frequency * texcoords2.s, frequency * texcoords2.t, speed * time))),
        amplitude * (snoise(vec3(frequency * texcoords2.s + 17.0, frequency * texcoords2.t, speed * time)))
    );
    gl_FragColor = texture2D(tex, texCoords);
}
</code></pre><h2 id=referencias>Referencias:
<a class=anchor href=#referencias>#</a></h2><ul><li><a href="http://erecursos.uacj.mx/bitstream/handle/20.500.11961/2902/Poster.pdf?sequence=2&amp;isAllowed=y">Zapata. F, Utilizando Algoritmos Generadores de Ruido.</a></li><li><a href=https://www.researchgate.net/publication/216813608_Simplex_noise_demystified>Gustavson. S, Simplex noise demystified</a></li><li><a href=https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83>Gonzalez. P, GLSL Noise Algorithms</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/VisualComputing/posteffects/commit/64fbc4b5e70a295f25db6f28e733ded12df4eacb title='Last modified by Diego Fernando Bulla Poveda | 28/09/2023' target=_blank rel=noopener><img src=/posteffects/svg/calendar.svg class=book-icon alt=Calendar>
<span>28/09/2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#ruido>Ruido</a><ul><li><a href=#código-del-fragment-shader-del-efecto>Código del Fragment Shader del efecto:</a><ul><li><a href=#ruido-simplex>Ruido Simplex.</a></li><li><a href=#función-principal>Función Principal</a></li></ul></li><li><a href=#referencias>Referencias:</a></li></ul></li></ul></nav></div></aside></main></body></html>