<!doctype html><html lang=es-co dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Profundidad de Campo # La profunidad de campo corresponde al área e nla que el ojo percibe un elemento con la nitidez suficiente o cuanto de la imagen es visualizable de forma nítida, si lo es en su totalidad se dice que se tiene una Profundidad de Campo Máxima.
Los objetos más cercanos a un plano de foco en la escena tendrán una nitidez mayor a los más lejanos. Solo aquellos que se encuentran en el plano poseerán un enfoque perfecto teoricamente, sin embargo el ojo brinda un rango de holgura que flexibiliza esta apreciación."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Profundidad de Campo # La profunidad de campo corresponde al área e nla que el ojo percibe un elemento con la nitidez suficiente o cuanto de la imagen es visualizable de forma nítida, si lo es en su totalidad se dice que se tiene una Profundidad de Campo Máxima.
Los objetos más cercanos a un plano de foco en la escena tendrán una nitidez mayor a los más lejanos. Solo aquellos que se encuentran en el plano poseerán un enfoque perfecto teoricamente, sin embargo el ojo brinda un rango de holgura que flexibiliza esta apreciación."><meta property="og:type" content="article"><meta property="og:url" content="https://visualcomputing.github.io/posteffects/docs/Efectos/Profundidad-de-Campo/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-10-02T14:03:11-05:00"><title>Profundidad De Campo | Posteffects</title><link rel=manifest href=/posteffects/manifest.json><link rel=icon href=/posteffects/favicon.png type=image/x-icon><link rel=stylesheet href=/posteffects/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/posteffects/flexsearch.min.js></script>
<script defer src=/posteffects/en.search.min.b7ed942c334359e14a86227f6d6bc53458875f53a31c25c9eb8b958a662f0530.js integrity="sha256-t+2ULDNDWeFKhiJ/bWvFNFiHX1OjHCXJ64uVimYvBTA=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/posteffects/><span>Posteffects</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><input type=checkbox id=section-0f516780f0e03c1811ded5819441605a class=toggle checked>
<label for=section-0f516780f0e03c1811ded5819441605a class="flex justify-between"><a role=button>Efectos</a></label><ul><li><a href=/posteffects/docs/Efectos/Mapa-de-Profundidad/>Mapa De Profundidad</a></li><li><a href=/posteffects/docs/Efectos/Profundidad-de-Campo/ class=active>Profundidad De Campo</a></li><li><a href=/posteffects/docs/Efectos/Pixelador/>Pixelador</a></li><li><a href=/posteffects/docs/Efectos/Detecci%C3%B3n-de-Bordes/>Detección De Bordes</a></li><li><a href=/posteffects/docs/Efectos/Desenfoque-Horizontal/>Desenfoque Horizontal</a></li><li><a href=/posteffects/docs/Efectos/Caleidoscopio/>Caleidoscopio</a></li><li><a href=/posteffects/docs/Efectos/Ruido/>Ruido</a></li><li><a href=/posteffects/docs/Efectos/Rayos/>Rayos</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-039690677835ee748aa00d86a9f370b9 class=toggle>
<label for=section-039690677835ee748aa00d86a9f370b9 class="flex justify-between"><a role=button>Apéndices</a></label><ul><li><a href=/posteffects/docs/Ap%C3%A9ndices/Apuntes-de-p5.treegl/>Apuntes De P5.treegl</a></li></ul></li><li class=book-section-flat><span>Monitoría Poo</span><ul><li><a href=/posteffects/docs/Monitor%C3%ADa-POO/Introducci%C3%B3n-a-JavaScript/>Introducción a Java Script</a></li><li><a href=/posteffects/docs/Monitor%C3%ADa-POO/Introducci%C3%B3n-a-p5/>Introducción a P5</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/posteffects/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Profundidad De Campo</strong>
<label for=toc-control><img src=/posteffects/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#profundidad-de-campo>Profundidad de Campo</a><ul><li><a href=#código-del-fragment-shader-del-efecto>Código del Fragment Shader del efecto:</a></li><li><a href=#referencias>Referencias.</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=profundidad-de-campo>Profundidad de Campo
<a class=anchor href=#profundidad-de-campo>#</a></h1><p>La profunidad de campo corresponde al área e nla que el ojo
percibe un elemento con la nitidez suficiente o cuanto de
la imagen es visualizable de forma nítida, si lo es
en su totalidad se dice que se tiene una Profundidad de
Campo Máxima.</p><p>Los objetos más cercanos a un plano de foco en la escena tendrán una nitidez mayor
a los más lejanos. Solo aquellos que se encuentran en el plano poseerán un enfoque perfecto teoricamente, sin
embargo el ojo brinda un rango de holgura que flexibiliza esta apreciación.
La profundidad de campo está ampliamente relacionada con la apertura, ya que a mayor apertura, más puntos habrá fuera de
foco; con la distancia focal, pues entre menor sea esta el área nítida de la imagen será mayor;</p><p>La siguiente visualización corresponde a una implementación de la profundidad de campo a manera
de efecto de posprocesado. las secciones superiores son respectivamente la escena principal y su
correspondiente mapa de profundidad; la inferior es el efecto aplicado. El plano focal cambia conforme
la posición de la esfera en movimiento varía.</p><iframe id=sketch style=width:625px;height:925px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/addons/p5.sound.min.js></script>
             <script src=https://cdn.jsdelivr.net/gh/freshfork/p5.EasyCam/p5.easycam.js></script> 
             <script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js></script> 
            
            
            
            <script src=/posteffects/sketches/dof/sketch.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h2 id=código-del-fragment-shader-del-efecto>Código del Fragment Shader del efecto:
<a class=anchor href=#c%c3%b3digo-del-fragment-shader-del-efecto>#</a></h2><p><details open><summary>dof.frag</summary><div class=markdown-inner><pre tabindex=0><code>precision mediump float;

uniform sampler2D texture;
uniform sampler2D depthMap;
uniform float maxBlur; 
uniform float aperture;
uniform float focus;
uniform float aspect;

varying vec2 texcoords2;

void main() {
    vec2 aspectcorrect = vec2( 1.0, aspect );
    vec4 depth1 = texture2D( depthMap, texcoords2 );
    float factor = depth1.x - focus;
    
    vec2 dofblur = vec2 ( clamp( factor * aperture, -maxBlur, maxBlur ) );
    vec2 dofblur9 = dofblur * 0.9;
    vec2 dofblur7 = dofblur * 0.7;
    vec2 dofblur4 = dofblur * 0.4;
    vec4 col = vec4( 0.0 );
    
    col += texture2D( texture, texcoords2.st );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.0, 0.4 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.15, 0.37 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.29, 0.29 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.37, 0.15 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.40, 0.0 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.37, -0.15 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.29, -0.29 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.0, -0.4 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.15, 0.37 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.29, 0.29 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.37, 0.15 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.4, 0.0 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.15, -0.37 ) * aspectcorrect ) * dofblur );
    
    col += texture2D( texture, texcoords2.st + ( vec2( 0.15, 0.37 ) * aspectcorrect ) * dofblur9 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.37, 0.15 ) * aspectcorrect ) * dofblur9 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.15, 0.37 ) * aspectcorrect ) * dofblur9 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.37, 0.15 ) * aspectcorrect ) * dofblur9 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
    
    col += texture2D( texture, texcoords2.st + ( vec2( 0.29, 0.29 ) * aspectcorrect ) * dofblur7 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.40, 0.0 ) * aspectcorrect ) * dofblur7 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.0, -0.4 ) * aspectcorrect ) * dofblur7 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.29, 0.29 ) * aspectcorrect ) * dofblur7 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.4, 0.0 ) * aspectcorrect ) * dofblur7 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.0, 0.4 ) * aspectcorrect ) * dofblur7 );
    
    col += texture2D( texture, texcoords2.st + ( vec2( 0.29, 0.29 ) * aspectcorrect ) * dofblur4 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.4, 0.0 ) * aspectcorrect ) * dofblur4 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.0, -0.4 ) * aspectcorrect ) * dofblur4 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.29, 0.29 ) * aspectcorrect ) * dofblur4 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.4, 0.0 ) * aspectcorrect ) * dofblur4 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.0, 0.4 ) * aspectcorrect ) * dofblur4 );
    
    gl_FragColor = col / 41.0;
    gl_FragColor.a = 1.0;
}
</code></pre></div></details>Es importante tener en cuenta el aspecto, que es la relación
entre las dimensiones de la imagen. Así mismo se extrae la profundidad
del fragmento actual usando el mapa de profundidad calculado previamente y se calcula
un factor de desenfoque que es la diferencia entre la coordenada <code>x</code>
de la profundidad y el foco.</p><pre tabindex=0><code>    vec2 aspectcorrect = vec2( 1.0, aspect );
    vec4 depth1 = texture2D( depthMap, texcoords2 );
    float factor = depth1.x - focus;
</code></pre><p>La distorsión estará dada por el factor de desenfoque, sin embargo no superará los límites
establecidos por su valor máximo (que está dado por el usuario en los controladores de la escena). Considerando
además que la distorsión depende de la distancia al plano focal, se establecen tres valores adicionales que serán
usados de acuerdo a cuán lejano está el foco respecto a la posición del fragmento y se establece una variable de
acumulación de color.</p><pre tabindex=0><code>    vec2 dofblur = vec2 ( clamp( factor * aperture, -maxBlur, maxBlur ) );
    vec2 dofblur9 = dofblur * 0.9;
    vec2 dofblur7 = dofblur * 0.7;
    vec2 dofblur4 = dofblur * 0.4;
    vec4 col = vec4( 0.0 );
</code></pre><p>La distorsión no se aplica usando una máscara en este caso, se usa la variable de acumulaición de color
<code>col</code> ppara sumar los valores de diferentes puntos de la textura correspondiente al buffer de la escena y aplicarles
su correspondiente factor de desenfoque de acuerdo a su posición.</p><pre tabindex=0><code>    col += texture2D( texture, texcoords2.st );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.0, 0.4 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.15, 0.37 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.29, 0.29 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.37, 0.15 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.40, 0.0 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.37, -0.15 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.29, -0.29 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.0, -0.4 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.15, 0.37 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.29, 0.29 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.37, 0.15 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.4, 0.0 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.15, -0.37 ) * aspectcorrect ) * dofblur );
    
    col += texture2D( texture, texcoords2.st + ( vec2( 0.15, 0.37 ) * aspectcorrect ) * dofblur9 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.37, 0.15 ) * aspectcorrect ) * dofblur9 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.15, 0.37 ) * aspectcorrect ) * dofblur9 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.37, 0.15 ) * aspectcorrect ) * dofblur9 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
    
    col += texture2D( texture, texcoords2.st + ( vec2( 0.29, 0.29 ) * aspectcorrect ) * dofblur7 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.40, 0.0 ) * aspectcorrect ) * dofblur7 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.0, -0.4 ) * aspectcorrect ) * dofblur7 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.29, 0.29 ) * aspectcorrect ) * dofblur7 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.4, 0.0 ) * aspectcorrect ) * dofblur7 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.0, 0.4 ) * aspectcorrect ) * dofblur7 );
    
    col += texture2D( texture, texcoords2.st + ( vec2( 0.29, 0.29 ) * aspectcorrect ) * dofblur4 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.4, 0.0 ) * aspectcorrect ) * dofblur4 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.0, -0.4 ) * aspectcorrect ) * dofblur4 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.29, 0.29 ) * aspectcorrect ) * dofblur4 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.4, 0.0 ) * aspectcorrect ) * dofblur4 );
    col += texture2D( texture, texcoords2.st + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
    col += texture2D( texture, texcoords2.st + ( vec2( 0.0, 0.4 ) * aspectcorrect ) * dofblur4 );
</code></pre><p>Finalmente se elimina la transparencia del color del fragmento y se establece el color acumulado como
valor de su atributo.</p><pre tabindex=0><code>    gl_FragColor = col / 41.0;
    gl_FragColor.a = 1.0;
</code></pre><h2 id=referencias>Referencias.
<a class=anchor href=#referencias>#</a></h2><ul><li><a href=https://www.dzoom.org.es/profundidad-de-campo/>DZOOM, La Profundidad de Campo Explicada con Ejemplos</a></li><li><a href=https://capturetheatlas.com/es/que-es-la-apertura-de-diafragma-en-fotografia/>Capture The Atlas, ¿Qué es la apertura de diafragma en fotografía?</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/VisualComputing/posteffects/commit/15d1df4e74888fd853d906bb082c697fbd5e073c title='Last modified by Diego Fernando Bulla Poveda | 02/10/2023' target=_blank rel=noopener><img src=/posteffects/svg/calendar.svg class=book-icon alt=Calendar>
<span>02/10/2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#profundidad-de-campo>Profundidad de Campo</a><ul><li><a href=#código-del-fragment-shader-del-efecto>Código del Fragment Shader del efecto:</a></li><li><a href=#referencias>Referencias.</a></li></ul></li></ul></nav></div></aside></main></body></html>